#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Simple Bot (SimpBot)
# Copyright 2016, Ismael Lugo (kwargs)

import simpbot
import logging
import time
import sys
import os
from signal import SIGTERM


logging = logging.getLogger('simpbot')
quit = lambda: exit('[ERROR]: Usar --debug para más información.')  # lint:ok

opt = simpbot.envvargs.args
opt.add_argument('-d', '--debug', action="store_true", dest='debug',
    help="Inicia el debug.")
opt.add_argument('-l', '--level', dest='level', type=int, metavar='level',
    help='Indica el nivel de debug.')

act = opt.add_argument_group("Opciones de lanzamiento")
act.add_argument('-a', '--action', type=str, metavar='(start|restart|stop)',
    help='Inicia, reinicia ó detiene SimpBot.')
act.add_argument('-nd', '--no-daemon',
    help='Lanza SimpBot sin demonizar.',
    dest='no_daemon', action='store_true')

cfg = opt.add_argument_group("Opciones de configuración.")
cfg.add_argument('-sc', '--server-conf', type=str, metavar="<nombre de la red>",
    dest="sc", help="Genera un archivo de configuración del servidor.")
cfg.add_argument('-ac', '--admin-conf',
    dest="ac", help="Genera el archivo de configuración de administradores.")
cfg.add_argument('-p', '--path', action='store_true',
    help="Indica el directorio donde se generara el archivo.")

try:
    import simpmods  # lint:ok
except ImportError:
    pass


args = opt.parse_args()


def config():
    if not args.sc and not args.ac:
        return

    if args.path:
        abspath = args.path
    elif args.sc:
        abspath = simpbot.envvars.servers.abspath
    elif args.ac:
        abspath = simpbot.envvars.workarea.abspath

    if args.sc:
        abspath = os.path.join(abspath, args.sc)
        if os.path.exist(abspath):
            logging.error('Nombre de red "%s" duplicado.', args.sc)
            exit(0)
        with file(abspath, 'w') as of:
            of.write(simpbot.bottools.dummy.ascii(';'))
            of.write(simpbot.samples.server.sample)
        exit(0)

    if args.ac:
        abspath = os.path.join(abspath, 'admins.ini')
        if os.path.exist(abspath):
            logging.error('Archivo "%s" existente.', abspath)
            exit(0)

        with file(abspath, 'w') as of:
            of.write(simpbot.bottools.dummy.ascii(';'))
            of.write(simpbot.samples.admins.sample)
        exit(0)


def debug():
    if not args.debug:
        level = 50
    else:
        level = 10
    if args.level:
        level = args.debug_level
    if args.action in ('start', 'restart'):
        if not args.no_daemon:
            simpbot.envvars.daemon = True
    simpbot.bottools.dummy.debug(level)


def action():
    if not args.action in ('start', 'restart', 'stop'):
        args.print_usage()
        return

    pidfile = '/tmp/simbot-%s.pid' % os.environ['USER']
    pid = None
    pid_status = False
    if os.path.exists(pidfile):
        pid = int(file(pidfile, 'r').read().splitlines()[0].replace('\n', ''))

        import errno
        if pid > 0:
            try:
                os.kill(pid, 0)
            except OSError as err:
                if err.errno == errno.EPERM:
                    pid_status = True
            else:
                pid_status = True

    if args.action in ('stop', 'restart'):
        if not pid_status:
            print('[!]- No hay ningun proceso activo')
            return

        try:
            while 1:
                os.kill(pid, SIGTERM)
                time.sleep(1)
        except OSError, err:
            err = str(err)
            if err.find("No such process") > 0:
                print('[+]- (PID: %s) SimpBot detenido.' % pid)
                os.remove(pidfile)
        if args.action == 'restart':
            pid_status = False
            args.action = 'start'
        else:
            return

    if args.action == 'start':
        if pid_status:
            print('[!]- Ya hay un proceso activo')
            return

        if not args.no_daemon:
            print('[+]- (PID: %s) SimpBot iniciado.' % os.getpid())
            null = '/dev/null'

            # Do first fork.
            try:
                pid = os.fork()
                if pid > 0:
                    sys.exit(0)   # Exit first parent.
            except OSError, e:
                sys.stderr.write("fork #1 failed: (%d) %s\n" % (e.errno, e.strerror))
                sys.exit(1)

            os.chdir("/")
            os.umask(0)
            os.setsid()
            try:
                pid = os.fork()
                if pid > 0:
                    sys.exit(0)   # Exit second parent.
            except OSError, e:
                sys.stderr.write("fork #2 failed: (%d) %s\n" % (e.errno, e.strerror))
                sys.exit(1)
            si = file(null, 'r')
            so = file(null, 'a+')
            se = file(null, 'a+', 0)
            pid = str(os.getpid())
            if pidfile:
                file(pidfile, 'w+').write("%s\n" % pid)
            os.dup2(si.fileno(), sys.stdin.fileno())
            os.dup2(so.fileno(), sys.stdout.fileno())
            os.dup2(se.fileno(), sys.stderr.fileno())

        for module in simpbot.modules.path.listdir():
            simpbot.modules.load_module(module, return_mod=False)
        if len(simpbot.envvars.coremodules) == 0:
            logging.error('No hay modulos disponibles!')
            exit(0)

        simpbot.admins.load_admins()
        if len(simpbot.envvars.admins) == 0:
            logging.error('Es necesario al menos un administrador!')
            exit(0)

        simpbot.connections.load_servers()
        if len(simpbot.envvars.nertworks) == 0:
            logging.error('No hay redes disponibles!')
            exit(0)

        while 1:
            try:
                time.sleep(60)
            except KeyboardInterrupt:
                exit(0)


if __name__ == '__main__':
    print(simpbot.bottools.dummy.ascii(''))
    debug()
    config()
    action()
